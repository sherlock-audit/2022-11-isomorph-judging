0x52

medium

# Swapping 100 tokens in DepositReceipt_ETH and DepositReciept_USDC breaks usage of sBTC LP

## Summary

DepositReceipt_ETH and DepositReciept_USDC checks the value of liquidity by swapping 100 tokens through the swap router. sBTC currenly only has ~49 tokens in existence. This makes sBTC completely incompatible with DepositReceipt_ETH and DepositReciept_USDC as the router will always throw an error when trying to calculate amountOut.

## Vulnerability Detail

        //check swap value of 100tokens to USDC to protect against flash loan attacks
        uint256 amountOut; //amount received by trade
        bool stablePool; //if the traded pool is stable or volatile.
        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);

The above lines try to swap 100 tokens from token1 to USDC. In the case of sBTC 100 tokens is a monstrous amount to swap. Given there are only ~49 sBTC on the network, it simply won't function. Additionally since the swap can only have a total slippage of 5%, it is likely that it will never work.

## Impact

sBTC LP is completely unusable

## Code Snippet

https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L93-L152

https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130

## Tool used

Manual Review

## Recommendation

Change the number of tokens to an immutable, so that it can be set individually for each token. Optionally you can add checks (shown below) to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. Similar changes should be made for DepositReceipt_ETH:

    constructor(string memory _name, 
                string memory _symbol, 
                address _router, 
                address _token0,
                address _token1,
                uint256 _tokensToSwap,
                bool _stable,
                address _priceFeed) 
                ERC721(_name, _symbol){

        ...

        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){
            require( IERC20Metadata(_token1).decimals() == 18, "Token does not have 18dp");

    +       (amountOut,) = _router.getAmountOut(_tokensToSwap, token1, USDC);

    +       //swapping tokens must yield at least 100 USDC
    +       require( amountOut >= 1e8);
    +       tokensToSwap = _tokensToSwap;
        }
        else
        {   
            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());
            require( keccak256(token1Symbol) == keccak256(USDCSymbol), "One token must be USDC");
            require( IERC20Metadata(_token0).decimals() == 18, "Token does not have 18dp");
            
    +       (amountOut, ) = _router.getAmountOut(_tokensToSwap, token0, USDC);

    +       //swapping tokens must yield at least 100 USDC
    +       require( amountOut >= 1e8);
    +       tokensToSwap = _tokensToSwap;
        }